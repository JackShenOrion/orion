package com.shenpinyi.hackerrank.graphs;

/**
 * Created by jack on 28/04/2017.
 */
public class Indexing {

    /**
     * 如何表示无向图和有向图
     *
     * 图由两部分组成:顶点集合,边集合
     *
     * 顶点比较容易表示,因为我们假设,所有的顶点都从0开始编号,于是可以将所有的顶点放到一个数组中。
     * 那么边集合怎么表示呢。分为两种情况:
     * 情况1:如果是密集图,那么使用相邻矩阵比较好,因为操作简单,另外矩阵中的每个节点可以用来表示边的权重。但是如果是稀疏图,那么就浪费空间了
     * 情况2:如果是稀疏图,那么使用邻接表比较合适。常见的表示就是顶点是数组,数组中的每个节点是List,List中存放顶点相邻的顶点列表
     *
     * 邻接表的样例参见:RoadsAndLibraries。
     *
     */

    /**
     * 如何找到从某一点出发的强连通子图(connected component)
     * 方法: 使用BFS和DFS都可以找到强连通子图。DFS使用递归代码更加简单。BFS就只能自己使用队列了。
     * BFS的样例参见: RoadsAndLibraries。
     */


    /**
     * 如何判断一个图有几个强连通子图
     * 方法: 遍历visited数组,对于每一个没有visited的顶点做一次强连通搜索。没新发现一个未visited的节点,强连通子图的个数就加一。
     * 样例参见: RoadsAndLibraries
     */

    /**
     * 如果广度优先遍历一个图
     * 方法: 使用队列保存新访问到的节点。使用visited数组保存是否被访问到。
     * 样例参见:RoadsAndLibraries
     */

    /**
     * 如何深度优先遍历一个图
     */
}
